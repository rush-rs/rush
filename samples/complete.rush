// This file should test all features of the rush programming language.

// expected exit-code: 100
// if the exit-code is 99, there is an error
fn main() {
        let int_ = 1;
        let float_ = 2.0;
        let char_ = 'a'; // 97
        let bool_ = true;
        let unit = produces_unit();
        let mut res = sum_different_types(int_, float_, unit, char_, bool_); // 101

        call_exit(
            assignments(res)
            + prefix_expr()
            + infix_arithmetic()
            + infix_logic()
            + casts()
            + call_params(),
            5
        )
}

fn call_exit(a: int, b: int) {
    exit(a + b)
}

fn produces_unit() {}
fn takes_unit(unit: ()) -> int { unit; 0 }

fn sum_different_types(
    int_: int,
    float_: float,
    unit: (),
    char_: char,
    bool_: bool,
) -> int {
    int_ + float_ as int + char_ as int + bool_ as int + takes_unit(unit)
}

// expected return-value: 1
fn prefix_expr() -> int {
    let one = -----1;
    let three = 3;
    let minus_2 = !1;
    let false_ = false;
    one + three + false_ as int + !false_ as int + !false_ as int + minus_2
}

// expected return-value: 1
fn infix_arithmetic() -> int {
    let one = 1;
    let two = 2;

    let thirty = (one + two) * two * 5;
    let three = (thirty / 2) % 4;
    let nine = (three ** 3) / 3;
    let nineteen = (((nine - 5) << 3) >> 1) | 3;
    let sixteen = nineteen ^ 3;
    (sixteen + 1) & 3
}

// expected return-value: 3
fn infix_logic() -> int {
    let true_ = true;
    let false_ = false;
    true_ || exit(99);
    false_ && exit(99);

    let true_ = (true_ || false_) && true_ && 1 < 2 && 1 <= 1 && (2 > 1) && (2 >= 2) && !(2 > 2) && !(2 < 2) && 2 == 2 && !(2 != 2) && 1 as bool && !(0 as bool);
    let false_ = (true_ && false_) || (false_ && true_) || 1 == 2 || 1 != 1;

    let three = true_ as int + false_ as int + 2;
    three
}

// expected return-value: 70
fn casts() -> int {
    let pi = 3.14159265;
    let six = ((pi - 0.14) * 2.0) as float as int;
    let true_ = 1 as bool && !(0 as bool);
    let b = 98 as char;
    let a = 'a';

    let zero = 0;
    let one = 1;
    let nine_flt = 9.9;
    let ten_flt = 10.0;

    b as int - (
        one as int + six as int + zero + true_ as int + ten_flt as bool as int + nine_flt as char as int
        + true_ as bool as int + true_ as float as int + true_ as char as char as int
        + six as char as float as int + a as bool as int + zero as char as bool as int
    )
}

fn assignments(mut res: int) -> int {
    // assignments
    res -= 51; // 50
    res *= 2; // 100
    res /= 10; // 10
    res %= 3; // 1
    res <<= 2; // 4
    res >>= 1; // 2
    res **= 3; // 8
    res |= 4; // 12
    res &= 4; // 4
    res += 3; // 7 (111)
    res ^= 3; // 4
    res
}

// expected return-value: 15
fn call_params() -> int {
    params(
        1,
        2.0,
        3 as char,
        true,
        1,
        2,
        3,
        1,
        3,
        1.9,
        2.1,
        3.0,
        4.0,
        5.0,
        6.0,
        7.0,
        8.0,
        8.9,
        10.9,
        5,
        6
    )
}

fn params(
    a: int,     // %rdi         | a0
    b: float,   // %xmm0        | fa0
    c: char,    // %sil         | a1
    d: bool,    // %dl          | a2
    e: int,     // %rcx         | a3
    f: int,     // %r8          | a4
    g: int,     // %r9          | a5
    h: int,     // [%rbp+16]    | a6
    i: int,     // [%rbp+24]    | a7
    j: float,   // %xmm1        | fa1
    k: float,   // %xmm2        | fa2
    l: float,   // %xmm3        | fa3
    m: float,   // %xmm4        | fa4
    n: float,   // %xmm5        | fa5
    o: float,   // %xmm6        | fa6
    p: float,   // %xmm7        | fa7
    q: float,   // [%rbp+32]    | 0(fp)
    r: float,   // [%rbp+40]    | 8(fp)
    s: float,   // [%rbp+48]    | 16(fp)
    t: int,     // [%rbp+56]    | 24(fp)
    u: int,     // [%rbp+64]    | 32(fp)
) -> int {
    a - b as int + c as int - d as int
    + e - f + g - h + i - t + u
    + (j + k - l + m - n + o - p + q - r + s) as int
}
